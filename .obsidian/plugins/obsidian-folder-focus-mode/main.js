/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => FolderFocusModePlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var FolderFocusModeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Auto-Focus when hidden").setDesc("Ensures the plugin focuses automatically on directory of newly opened files, if they are not visible right now").addToggle((component) => component.setValue(this.plugin.settings.autofocusMode).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autofocusMode = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Auto-Focus on root").setDesc("Focus on the first folder from root if the auto focus setting is enabled").addToggle((component) => component.setValue(this.plugin.settings.autofocusRoot).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autofocusRoot = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Force auto-focus on parent directory").setDesc("Always auto-focus on the parent directory of current file, even if it is already visible").addToggle((component) => component.setValue(this.plugin.settings.autofocusForced).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autofocusForced = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Simplified view").setDesc("Hide parent directories when focusing on a folder (saves space when using nested folders)").addToggle((component) => component.setValue(this.plugin.settings.simplifiedView).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.simplifiedView = value;
      this.plugin.resetClasses();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Button on explorer").setDesc("Add a button on the top of the file explorer").addToggle((component) => component.setValue(this.plugin.settings.focusButton).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.focusButton = value;
      this.plugin.initialiseFocusButton(value);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Show focus option on file context menu").setDesc('Show "Focus on this file" option in file context menu').addToggle((component) => component.setValue(this.plugin.settings.fileContextMenu).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.fileContextMenu = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Folder Note: External files").setDesc("Focus on the folder linked with the folder note").addToggle((component) => component.setValue(this.plugin.settings.focusNote).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.focusNote = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// util.ts
var normalizeArray = (parts, allowAboveRoot) => {
  const res = [];
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    if (!p || p === ".")
      continue;
    if (p === "..") {
      if (res.length && res[res.length - 1] !== "..") {
        res.pop();
      } else if (allowAboveRoot) {
        res.push("..");
      }
    } else {
      res.push(p);
    }
  }
  return res;
};
var trimArray = (arr) => {
  const lastIndex = arr.length - 1;
  let start = 0;
  for (; start <= lastIndex; start++) {
    if (arr[start])
      break;
  }
  let end = lastIndex;
  for (; end >= 0; end--) {
    if (arr[end])
      break;
  }
  if (start === 0 && end === lastIndex)
    return arr;
  if (start > end)
    return [];
  return arr.slice(start, end + 1);
};
var resolve = (path) => {
  let resolvedPath = "", resolvedAbsolute;
  resolvedPath = path + "/" + resolvedPath;
  resolvedAbsolute = path[0] === "/";
  resolvedPath = normalizeArray(resolvedPath.split("/"), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
};
var getRelativePath = (from, to) => {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);
  const fromParts = trimArray(from.split("/"));
  const toParts = trimArray(to.split("/"));
  const length = Math.min(fromParts.length, toParts.length);
  let samePartsLength = length;
  for (let i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  let outputParts = [];
  for (let i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
};
var isAbsolutePath = (path) => {
  return path.charAt(0) === "/";
};
var getDirname = (path) => {
  return path.substring(0, path.lastIndexOf("/"));
};
var getRootDirname = (path) => {
  return path.substring(0, path.indexOf("/"));
};

// main.ts
var DEFAULT_SETTINGS = {
  autofocusMode: true,
  autofocusRoot: false,
  autofocusForced: false,
  simplifiedView: true,
  focusButton: true,
  focusNote: false,
  fileContextMenu: false
};
var VisibilityType;
(function(VisibilityType2) {
  VisibilityType2[VisibilityType2["hide"] = 0] = "hide";
  VisibilityType2[VisibilityType2["showAsParent"] = 1] = "showAsParent";
  VisibilityType2[VisibilityType2["showAsHeader"] = 2] = "showAsHeader";
  VisibilityType2[VisibilityType2["showAsBack"] = 3] = "showAsBack";
  VisibilityType2[VisibilityType2["alwaysShow"] = 4] = "alwaysShow";
})(VisibilityType || (VisibilityType = {}));
var FolderFocusModePlugin = class extends import_obsidian2.Plugin {
  shouldBeVisible(focusFolder, currentFolder) {
    const relative = getRelativePath(focusFolder, currentFolder);
    const stringSplits = focusFolder.split("/");
    const parentsArray = stringSplits.reduce((acc, val, i) => {
      if (i === 0)
        return [val];
      acc.push(acc[i - 1] + "/" + val);
      return acc;
    }, []);
    const upElement = parentsArray.length >= 2 ? parentsArray[parentsArray.length - 2] : "/";
    if (focusFolder === currentFolder) {
      return 2;
    }
    if (upElement === currentFolder) {
      return 3;
    }
    if (parentsArray.includes(currentFolder)) {
      return 1;
    }
    if (currentFolder === "/") {
      return 1;
    }
    if (relative && !relative.startsWith("..") && !isAbsolutePath(relative)) {
      return 4;
    }
    return 0;
  }
  hideTreeElements(newFocusFolder) {
    this.focusModeEnabled = true;
    this.focusModePath = newFocusFolder;
    this.resetClasses();
    const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((fileExplorer) => {
      let newTree = fileExplorer.view.fileItems;
      for (const key in fileExplorer.view.fileItems) {
        if (fileExplorer.view.fileItems.hasOwnProperty(key)) {
          const shouldBeVisible = this.shouldBeVisible(newFocusFolder, key);
          this.substituteSetterForElement(fileExplorer.view.fileItems[key]);
          if (shouldBeVisible) {
            fileExplorer.view.fileItems[key].el.classList.remove("hidden-tree-element");
          } else {
            fileExplorer.view.fileItems[key].el.classList.add("hidden-tree-element");
          }
          if (shouldBeVisible === 1) {
            this.substituteSetterForElement(fileExplorer.view.fileItems[key], false);
            fileExplorer.view.fileItems[key].el.classList.add("folderfocus-parent");
          } else {
            fileExplorer.view.fileItems[key].el.classList.remove("folderfocus-parent");
          }
          if (shouldBeVisible === 2) {
            this.substituteSetterForElement(fileExplorer.view.fileItems[key], false);
            fileExplorer.view.fileItems[key].el.classList.add("folderfocus-header");
          } else {
            fileExplorer.view.fileItems[key].el.classList.remove("folderfocus-header");
          }
          if (shouldBeVisible === 3) {
            this.substituteSetterForElement(fileExplorer.view.fileItems[key], false);
            fileExplorer.view.fileItems[key].el.classList.add("folderfocus-up-element");
            fileExplorer.view.fileItems[key].el.children[0].classList.add("folderfocus-up-element-link");
          } else {
            fileExplorer.view.fileItems[key].el.classList.remove("folderfocus-up-element");
            fileExplorer.view.fileItems[key].el.children[0].classList.remove("folderfocus-up-element-link");
          }
        }
      }
      const existingButton = FolderFocusModePlugin.getFocusButton(fileExplorer);
      if (existingButton) {
        this.setFocusedIconButton(existingButton);
      }
    });
  }
  showAllTreeElements() {
    this.focusModeEnabled = false;
    this.focusModePath = null;
    const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((fileExplorer) => {
      var _a, _b;
      for (const key in fileExplorer.view.fileItems) {
        if (fileExplorer.view.fileItems.hasOwnProperty(key)) {
          fileExplorer.view.fileItems[key].el.classList.remove("hidden-tree-element");
          fileExplorer.view.fileItems[key].el.classList.remove("folderfocus-parent");
          fileExplorer.view.fileItems[key].el.classList.remove("folderfocus-up-parent");
        }
      }
      (_b = (_a = fileExplorer.view.containerEl.querySelector(".folderfocus-up-element-link")) == null ? void 0 : _a.classList) == null ? void 0 : _b.remove("folderfocus-up-element-link");
      const existingButton = FolderFocusModePlugin.getFocusButton(fileExplorer);
      if (existingButton) {
        this.setUnfocusedIconButton(existingButton);
      }
    });
  }
  getDirRoot(file) {
    if (this.settings.focusNote) {
      const linkedFolder = this.app.vault.getAbstractFileByPath(file.path.replace(".md", ""));
      if (linkedFolder && linkedFolder instanceof import_obsidian2.TFolder) {
        return linkedFolder.path;
      } else {
        return this.settings.autofocusRoot ? getRootDirname(file.path) : getDirname(file.path);
      }
    } else {
      return this.settings.autofocusRoot ? getRootDirname(file.path) : getDirname(file.path);
    }
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  initialiseFocusButton(forcedValue) {
    var _a;
    const settingCheck = forcedValue ? forcedValue : (_a = this == null ? void 0 : this.settings) == null ? void 0 : _a.focusButton;
    const explorers = (this == null ? void 0 : this.getFileExplorers()) || [];
    explorers.forEach((exp) => {
      if (settingCheck) {
        this.addFocusFolderButton(exp);
      } else {
        this.removeFocusFolderButton(exp);
      }
    });
  }
  initialiseUpButton() {
    const explorers = (this == null ? void 0 : this.getFileExplorers()) || [];
    explorers.forEach((explorer) => {
      this.registerDomEvent(explorer.view.containerEl, "click", (evt) => {
        var _a;
        const elemTarget = evt.target;
        const realTarget = elemTarget.closest(".folderfocus-up-element-link");
        if (this.settings.simplifiedView && realTarget) {
          const upPath = (_a = realTarget.dataset) == null ? void 0 : _a.path;
          if (upPath) {
            this.hideTreeElements(upPath);
            setTimeout(() => {
              elemTarget.click();
            }, 300);
          }
        }
      });
    });
  }
  toggleFocusOption(focused, path) {
    if (focused) {
      this.showAllTreeElements();
    } else {
      this.hideTreeElements(path);
    }
  }
  initialiseFileContextMenu(menu, file) {
    var _a;
    if (!(file == null ? void 0 : file.extension)) {
      const isCurrentlyFocused = this.focusModePath === file.path;
      menu.addItem((item) => {
        item.setTitle(isCurrentlyFocused ? "Unfocus" : "Focus on this folder").setIcon("eye").onClick(() => __async(this, null, function* () {
          return this.toggleFocusOption(isCurrentlyFocused, file.path);
        }));
      });
    } else {
      const isCurrentlyFocused = this.focusModePath === ((_a = file == null ? void 0 : file.parent) == null ? void 0 : _a.path);
      if (this.settings.fileContextMenu) {
        menu.addItem((item) => {
          item.setTitle(isCurrentlyFocused ? "Unfocus" : "Focus on this file").setIcon("eye").onClick(() => __async(this, null, function* () {
            var _a2;
            return this.toggleFocusOption(isCurrentlyFocused, (_a2 = file == null ? void 0 : file.parent) == null ? void 0 : _a2.path);
          }));
        });
      }
    }
  }
  substituteSetterForElement(el, allowCollapse = true) {
    el.__defineSetter__("collapsed", function(newValue) {
      document.dispatchEvent(new Event("collapse-changed"));
      if (!allowCollapse) {
        this._collapsed = true;
      } else {
        this._collapsed = newValue;
      }
    });
    el.__defineGetter__("collapsed", function() {
      return this._collapsed;
    });
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new FolderFocusModeSettingTab(this.app, this));
      const explorers = this.getFileExplorers();
      this.focusModeEnabled = false;
      this.app.workspace.onLayoutReady(() => this.initialiseFocusButton());
      this.registerEvent(this.app.workspace.on("layout-change", this.initialiseFocusButton));
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => this.initialiseFileContextMenu(menu, file)));
      this.app.workspace.onLayoutReady(() => this.initialiseUpButton());
      this.registerEvent(this.app.workspace.on("layout-change", this.initialiseUpButton));
      this.registerEvent(this.app.workspace.on("file-open", (file) => {
        if (!this.focusModeEnabled)
          return;
        const shouldHandleForRegularMode = !this.settings.autofocusForced && !this.shouldBeVisible(this.focusModePath, file.path);
        const shouldHandleForForcedMode = this.settings.autofocusForced;
        const shouldHandleAutofocus = this.settings.autofocusMode && (shouldHandleForRegularMode || shouldHandleForForcedMode);
        if (shouldHandleAutofocus) {
          const currentFolderPath = this.getDirRoot(file);
          this.hideTreeElements(currentFolderPath);
          const explorers2 = this.getFileExplorers();
          explorers2.forEach((exp) => {
            const container = exp.view.containerEl;
            const navContainer = container.querySelector("div.nav-buttons-container");
            if (!navContainer) {
              return null;
            }
            const existingButton = FolderFocusModePlugin.getFocusButton(exp);
            existingButton.classList.add("focus-close");
            this.addFocusFolderButton(exp);
          });
        }
      }));
      this.addCommand({
        id: "folder-focus-mode-unfocus",
        name: "Disable folder focus mode",
        callback: () => {
          this.showAllTreeElements();
        }
      });
      this.addCommand({
        id: "folder-focus-mode-toggle-autofocus",
        name: "Toggle autofocus mode",
        callback: () => {
          this.settings.autofocusMode = !this.settings.autofocusMode;
        }
      });
      this.addCommand({
        id: "folder-focus-mode-toggle-simplified",
        name: "Toggle simplified view",
        callback: () => {
          this.settings.simplifiedView = !this.settings.simplifiedView;
          this.resetClasses();
        }
      });
      this.addCommand({
        id: "folder-focus-mode-focus-active",
        name: "Enable folder focus mode for active file",
        checkCallback: (checking) => {
          const currentFile = this.app.workspace.getActiveFile();
          if (currentFile) {
            if (!checking) {
              const currentFolderPath = getDirname(currentFile.path);
              this.hideTreeElements(currentFolderPath);
            }
            return true;
          }
          return false;
        }
      });
    });
  }
  onunload() {
    const explorers = this.getFileExplorers();
    explorers.forEach((exp) => {
      this.removeFocusFolderButton(exp);
    });
  }
  resetClasses() {
    const explorers = this.getFileExplorers();
    explorers.forEach((fileExplorer) => {
      if (this.focusModeEnabled) {
        fileExplorer.view.containerEl.classList.add("folder-focus-mode");
      } else {
        fileExplorer.view.containerEl.classList.remove("folder-focus-mode");
      }
      if (this.settings.simplifiedView) {
        fileExplorer.view.containerEl.classList.add("folder-focus-mode-simplified");
      } else {
        fileExplorer.view.containerEl.classList.remove("folder-focus-mode-simplified");
      }
    });
  }
  getFileExplorers() {
    return this.app.workspace.getLeavesOfType("file-explorer");
  }
  static getFocusButton(explorer) {
    return explorer.view.containerEl.querySelector(".focus-folder-button");
  }
  setUnfocusedIconButton(icon) {
    (0, import_obsidian2.setIcon)(icon, "eye");
    icon.classList.remove("focus-close");
    icon.classList.add("focus-open");
    icon.setAttribute("aria-label", "Focus on this file folder");
  }
  setFocusedIconButton(icon) {
    (0, import_obsidian2.setIcon)(icon, "eye-off");
    icon.classList.remove("focus-open");
    icon.classList.add("focus-close");
    icon.setAttribute("aria-label", "Unfocus folder");
  }
  addFocusFolderButton(explorer) {
    const container = explorer.view.containerEl;
    const navContainer = container.querySelector("div.nav-buttons-container");
    if (!navContainer) {
      return null;
    }
    const existingButton = FolderFocusModePlugin.getFocusButton(explorer);
    if (existingButton) {
      return;
    }
    const newIcon = document.createElement("div");
    newIcon.classList.add("nav-action-button", "focus-folder-button", "focus-open", "clickable-icon");
    if (this.focusModeEnabled) {
      this.setFocusedIconButton(newIcon);
    } else {
      this.setUnfocusedIconButton(newIcon);
    }
    this.registerDomEvent(newIcon, "click", () => {
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        const isCurrentlyFocused = this.focusModePath === currentFile.path;
        if (isCurrentlyFocused || newIcon.classList.contains("focus-close")) {
          this.showAllTreeElements();
          this.setUnfocusedIconButton(newIcon);
        } else if (newIcon.classList.contains("focus-open")) {
          const currentFolderPath = this.getDirRoot(currentFile);
          this.hideTreeElements(currentFolderPath);
          this.setFocusedIconButton(newIcon);
        }
      }
    });
    navContainer.appendChild(newIcon);
  }
  removeFocusFolderButton(explorer) {
    const button = FolderFocusModePlugin.getFocusButton(explorer);
    if (button) {
      button.remove();
    }
  }
};
